@model ProductoViewModel
<section class="d-flex justify-content-center align-items-center" style="height: 70vh;">
    <article class="border rounded p-5">
        <form asp-asp-controller="Producto" asp-action="ConfirmarModificarProducto" method="post">
            <section class="form-group p-2">
                <label asp-for="Descripcion" class="form-label" value="@Model.Descripcion">Descripcion</label>
                <input type="text" asp-for="Descripcion" class="form-control-sm">
                <span asp-validation-for="Descripcion" class="text-danger"></span>
            </section>
            <section class="form-group d-flex justify-content-between p-2">
                <label asp-for="Precio" class="form-label" value="@Model.Precio">Precio</label>
                <input type="number" asp-for="Precio" class="form-control-sm">
                <span asp-validation-for="Precio" class="text-danger"></span>
            </section>
            <section>
                <input type="hidden" asp-for="IdProducto" value="@Model.IdProducto">
            </section>
            <section class="form-group p-2">
                <input type="submit" value="Modificar" class="btn btn-primary">
                <a class="btn btn-danger " asp-controller="Producto" asp-action="Index">Cancelar</a>
            </section>
        </form>
        @section Scripts {
            <partial name="_ValidationScriptsPartial" />
        }
        @*// asp-for conecta los modelos con el formulario, es decir que automaticamente se crea el objeto*@
    </article>
</section>
@*el @model: 
*Recibe datos: Cuando el controlador renderiza una vista, el modelo contiene los datos que se mostrarán.
*Envía datos: Cuando el formulario se envía al servidor, el modelo puede usarse para mapear los datos enviados.
en este caso se los enviamos al formulario (te das cuenta si en el controlador retorna la vista sola o con algo, si va vacia el model en la vista envia los datos, si retorna algo, el model recibe los datos en la vista)*@